import random

class 푸키먼:
    # 세상의 모든 포켓몬은 고유 번호를 가진다.
    # 각 인스턴스의 고유번호가 X
    # 피카츄라는 종은 n번의 고유번호를 가진다.
    # 클래스 변수로 설정
    고유번호 = '세상의 모든 포켓몬은 고유 번호를 가진다.'
    현재_발견된_총_푸키먼_수 = 0
    푸키먼_종류 = {}

    # 생성자 메서드
    def __init__(self, 종, 타입, 속도, 스킬1='몸통 박치기', 체력=100, 레벨=1):
        self.종 = 종
        self.타입 = 타입
        self.속도 = 속도
        self.스킬1 = 스킬1
        self.체력 = 체력
        self.레벨 = 레벨
        푸키먼.새로운_포켓몬_탄생(종)
        self.고유번호 = 푸키먼.푸키먼_종류[종][0]
        
    
    # 인스턴스 메서드
    def 스킬1_사용(self):
        print(f'{self.종}은(는) {self.스킬1}을 사용하였다!')
    
        주사위 = random.randint(1, 6) # 1~6 수 중 무작위 하나 반환
        if 주사위 == 6:
            print('효과는 굉장했다.')
        elif 주사위 >= 3:
            print('적에게 적중했다.')
        else:
            print('효과는 미미했다.')

    # 클래스 메서드
    @classmethod
    def 새로운_포켓몬_탄생(cls, 종):
        # 인스턴스 생성된 순간에만 호출
        cls.현재_발견된_총_푸키먼_수 += 1
        # 만약 처음 발견한 종이라면
        if 종 not in cls.푸키먼_종류:
            print('한 번도 본 적 없던 푸키먼이다!')
            # 종의 고유 번호 => 푸키먼_종류 딕셔너리의 총 길이 +1
            # [종의 고유 번호, 종의 개체수]
            cls.푸키먼_종류[종] = [len(cls.푸키먼_종류)+1, 1]
            print(f'{종}! 앞으로 너의 고유 번호는 {cls.푸키먼_종류[종][0]}번이야!')
            pass
        # 아니라면
        else:
            print(f'{종}의 개체수가 1 증가하였다!')
            cls.푸키먼_종류[종][1] += 1
            print(f'{종}의 총 개체수는 {cls.푸키먼_종류[종][1]}')
            pass
    
    # 스태틱 메서드
    @staticmethod
    def 푸키먼이란():
        return '포켓몬이란.. 게임을 기반으로 어쩌구 저쩌구 ~'
    # 클래스의 어떠한 행위나, 직접적인 클래스 변수가 아닌 다른 값
    # 하지만 이 클래스와 연관되어 있는 어떠한 행위들

    @staticmethod
    def 특정_레벨의_경험치_요구량(lv):
        return lv * 200
    
    def 현재_내_레벨의_경험치_요구량(self):
        return self.lv * 200
    
    # 소멸자
    def __del__(self):
        print(f'{self.종}! 잘 지내거라.')
    
    # 호출도 가능
    def __call__(self):
        return self.종[:2] * 2
    
    # 사용자를 위한 정보 반환
    def __str__(self):
        return f"스킬: {self.스킬1}, 체력: {self.체력}, 레벨: {self.레벨}"
    
    # 개발자를 위한 정보 반환
    # 해당 객체가 어떤 타입인지 등 가이드가 될 수 있는 정보
    def __repr__(self):
        return '푸키먼()'


class 피카츄(푸키먼):
    def __init__(self, 종='피카츄', 타입='전기', 속도=100, 스킬1='몸통 박치기', 체력=100, 레벨=1):
        super().__init__(종, 타입, 속도, 스킬1, 체력, 레벨)

# 푸키먼 클래스의 인스턴스를 생성 후 피카츄 변수에 할당
피카츄 = 피카츄()
파이리 = 푸키먼('파이리', '불', 100)
피카츄2 = 피카츄()
갸라도스 = 푸키먼('갸라도스', '물', 200)
print(f'피카츄를 부르면 {피카츄()} 하고 웁니다.')
print(피카츄)
# 피카츄 변수에 할당된 인스턴스의 속성 고유번호를 출력
# print(f'피카츄 : {피카츄.__dict__}')
# print(f'갸라도스 : {갸라도스.__dict__}')

# 영역 내에서만 변수 찾음 / 글로벌에서는 찾지 않는다
# 글로벌_변수 = '글로벌'
# print(피카츄.글로벌_변수)

# 각 인스턴스로 메서드 호출
# 피카츄.스킬1_사용()
# 갸라도스.스킬1_사용()

# 내부 동작 방식을 직접 작성했을 때 실제로 이뤄지는 행위
# print('hello'.upper()) # print(str.upper('hello'))
# print('hello'.upper('hello', 'hello'))
# 그러면 왜 헷갈리게 파라미터는 self는 지정해놓고 인자는 안 쓰는가?
# self 지정하는 것은 필수 / 인자 안쓰는 것은 개발자의 개발 편의를 위해 (중복 내용 작성 안하기 위해)

# 피카츄.고유번호 = 1
# 갸라도스.고유번호 = 2
# print(f'피카츄.고유번호 = {피카츄.고유번호}')
# print(f'갸라도스.고유번호 = {갸라도스.고유번호}')
# print(f'푸키먼.고유번호 = {푸키먼.고유번호}')